# M5StickCPlus2 다기능 측정 장치 코드 분석 보고서

**문서 버전:** 1.0
**작성일:** 2025년 5월 10일
**작성자:** AI 분석 도구

## 1. 개요

본 보고서는 제공된 "MPAS_CE.txt" 파일의 Arduino 코드에 대한 상세 분석을 제공합니다. 이 코드는 M5StickCPlus2 장치를 위한 다기능 측정 애플리케이션으로, 다양한 센서 데이터(마이크, 관성 측정 장치(IMU))를 활용하여 여러 가지 유용한 기능을 제공합니다. 주요 기능으로는 실시간 센서 데이터 표시, 모터 주파수 레벨 측정, 스톱워치, 경과 시간 시계, 수평계, QR 코드 표시 등이 있으며, 사용자 인터페이스는 장치에 내장된 버튼과 LCD 디스플레이를 통해 이루어집니다.

## 2. 사용된 하드웨어 및 라이브러리

본 애플리케이션은 M5StickCPlus2의 다음과 같은 내장 하드웨어 및 기능을 활용합니다:

* **MCU:** ESP32-PICO-D4 기반 마이크로컨트롤러
* **디스플레이:** 1.14인치 TFT LCD (240x135 해상도)
* **입력:** 버튼 A, 버튼 B
* **센서:**
    * SPM1423 (I2S MEMS 마이크로폰)
    * SH200Q 또는 MPU6886 (6축 IMU - 가속도계, 자이로스코프)
* **전원 관리:** AXP192 PMIC (배터리 전압 측정 등)
* **기타:** 내장 부저, LED

주요 사용 라이브러리는 다음과 같습니다:

* `M5StickCPlus2.h`: M5StickCPlus2 장치 제어를 위한 기본 라이브러리
* `arduinoFFT.h`: 고속 푸리에 변환(FFT)을 수행하여 주파수 분석에 사용
* `math.h`, `cmath`: 수학적 연산 수행

## 3. 전역 설정 및 변수

코드 전반에 걸쳐 사용되는 주요 전역 설정 및 변수는 다음과 같습니다.

* **색상 정의:** `WHITE`, `BLUE`, `ORANGE` 등 다양한 16비트 색상 값이 매크로로 정의되어 UI에 활용됩니다. 
* **더블 버퍼링:** `M5Canvas sprite(&M5.Display);`를 통해 LCD 화면 깜빡임을 줄이고 부드러운 화면 전환을 위한 스프라이트 객체를 사용합니다. 
* **버튼 처리 변수:** `btnAPressStart`, `longPressTriggered`, `btnBPressStart`, `bLongPressTriggered` 등 버튼의 눌림 시작 시간과 길게 누름 상태를 감지하기 위한 변수들이 사용됩니다. 
* **모드 관리:** `mode` 변수는 현재 활성화된 기능을 나타내며 (0: 센서, 1: 모터 레벨, 2: 스톱워치, 3: 시계, 4: 수평계, 5: QR, 6: 미정의), `prevMode`는 이전 모드를 저장하여 모드 전환 시 화면 초기화 등에 사용됩니다. 
* **FFT 설정:** 마이크 입력을 통한 주파수 분석을 위해 샘플 개수(`SAMPLES = 1024`), 샘플링 주파수(`SAMPLING_FREQUENCY = 2453`) 등이 정의되어 있습니다. 
* **부저 핀:** `BUZZ_PIN`이 2번으로 정의되어 부저 제어에 사용됩니다. 

## 4. 모드별 기능 상세 분석

애플리케이션은 총 7개의 모드(0부터 6까지)를 가지며, 각 모드는 고유한 기능을 수행합니다. 모드 전환은 주로 버튼 B의 짧게 누름 또는 길게 누름으로 이루어집니다.

### 4.1. 모드 0: 센서 모드

* **기능:** 마이크를 통해 주변 소리(주로 모터 소음)를 분석하여 주파수를 측정하고, 이를 바탕으로 RPM 및 예상 속도를 계산하여 표시합니다. 배터리 잔량과 함께 주파수, 속도, 전압을 그래프 형태로 시각화합니다.
* **주요 로직:**
    * `calculateFrequency()` 함수를 호출하여 마이크로부터 오디오 데이터를 수집하고, 저역 통과 필터 적용 후 FFT를 수행하여 주요 주파수를 추출합니다. 추출된 주파수는 이동 평균 필터를 거쳐 안정화됩니다. 주파수가 30Hz 미만이면 노이즈로 간주하여 0으로 처리합니다. 
    * 측정된 주파수($f$)로부터 RPM은 $RPM = f \times 60$으로 계산됩니다. 
    * 사용자가 버튼 A를 짧게 또는 길게 눌러 선택한 휠 크기(`wheelSizes`)와 기어비(`gearRatios`)를 바탕으로 예상 속도($v$)를 계산합니다: $v = (RPM / \text{selectedGear}) \times (\pi \times \text{currentWheelDiameter} \times 0.06)$ (km/h 단위). 
    * `drawGraph()` 함수를 통해 화면 우측에 주파수, 속도, 배터리 전압을 막대그래프로 표시합니다. 이때, 주파수와 속도 값은 부드러운 시각적 변화를 위해 스무딩 처리됩니다. 
    * 배터리 잔량은 `getBatteryPercent()` 함수를 통해 계산되며, 10% 이하일 경우 LED와 화면 표시를 통해 경고합니다. 
* **사용자 인터페이스:**
    * 화면 좌측 상단: 현재 선택된 휠 크기 (mm) 표시. 
    * 화면 우측 상단: 배터리 전압(mV) 및 잔량(%) 표시 (낮은 잔량 시 깜빡임). 
    * 화면 중앙: 현재 주파수(Hz), RPM, 예상 속도(km/h) 표시. 
    * 화면 하단: 펌웨어 버전 정보 표시. 
    * 버튼 A 짧게 누름: 기어비 변경. 
    * 버튼 A 1~2초 누름: 휠 크기 변경. 
    * IMU의 Yaw 값을 이용한 자동 화면 회전 및 모드 1로의 전환 기능이 포함되어 있습니다. 

### 4.2. 모드 1: 특정 모터 레벨 측정 모드

* **기능:** 미리 정의된 여러 종류의 모터(`motors` 배열) 각각에 대해 설정된 최대 임계 주파수(`maxThreshold`) 대비 현재 측정된 주파수의 비율을 프로그레스 바로 시각화합니다. 
* **주요 로직:**
    * `calculateFrequency()`를 통해 현재 주파수를 얻습니다.
    * 선택된 모터의 `maxThreshold` 값 대비 현재 주파수의 비율(`ratio`)을 계산합니다 (0.0 ~ 1.0 범위). 
    * 이 비율은 지수 이동 평균 필터(`smoothRatio`)를 통해 부드럽게 처리됩니다. 
    * 계산된 `smoothRatio`에 따라 화면에 가로 프로그레스 바를 그립니다. 바는 여러 개의 '벽돌'로 구성되며, 채워진 부분은 그라데이션 색상으로 표시되고, 목표 지점은 빨간색으로 표시됩니다. 
* **사용자 인터페이스:**
    * 화면 중앙: 선택된 모터의 목표 주파수 대비 현재 주파수 레벨을 프로그레스 바로 표시.
    * 화면 하단: 현재 선택된 모터의 이름, 설정된 최대 임계 주파수, 현재 측정 주파수를 텍스트로 표시. 
    * 버튼 A 짧게 누름: 다음 모터 종류로 변경. 
    * 모드 0과 유사하게 IMU Yaw 값에 따라 모드 0으로 자동 전환되는 기능이 있습니다. 

### 4.3. 모드 2: 스톱워치 모드

* **기능:** 기본적인 스톱워치 기능과 함께 랩 타임 기록, 지정된 랩 수(2, 3, 5랩) 달성 시 기록 표시 및 깜빡임 알림, 5초 카운트다운 후 자동 시작 기능을 제공합니다.
* **주요 로직:**
    * 버튼 A 짧게 누름: 스톱워치 시작/랩 기록/정지 토글. 
        * 정지 상태에서 누르면 시작.
        * 실행 중 누르면 랩 타임 기록 (설정된 `splitTarget` 미만까지).
        * 마지막 랩 기록 시 정지.
    * 버튼 A 길게(1초 이상) 누름: 5초 카운트다운 시작. 카운트다운 중에는 "Ready??"와 남은 시간이 표시되며, 3초 이하부터 비프음이 발생합니다. 카운트다운 종료 시 "Go!!" 메시지와 함께 스톱워치가 자동으로 시작됩니다. 
    * 버튼 B 길게(2초 이상) 누름: 랩 타겟(2, 3, 5랩)을 순환 변경합니다. 
    * 시간 표시는 분:초.백분의일초 형식(`MM:SS.CS`)입니다. 
    * 랩 타임은 최근 5개까지 화면에 표시됩니다. 
    * 목표 랩 수 도달 후 정지 시, 최종 기록이 깜빡입니다. 
    * IMU 센서를 이용한 자동 화면 회전 기능이 포함되어 있습니다. 
* **사용자 인터페이스:**
    * 화면 상단: 현재 스톱워치 시간 또는 카운트다운 표시. 랩 타겟에 따라 색상 변경 (2랩: 녹색, 3랩: 파란색, 5랩: 주황색). 
    * 화면 하단: 기록된 랩 타임 및 누적 시간 표시.

### 4.4. 모드 3: 경과 시간 시계 모드

* **기능:** 장치 부팅 후 또는 사용자가 초기화한 시점부터 경과된 시간을 시:분:초 형식으로 표시합니다. 일시 정지 및 재개 기능을 제공하며, 배터리 잔량을 표시합니다.
* **주요 로직:**
    * `millis()` 함수를 사용하여 경과 시간을 계산합니다. `clockStartTime`은 시작 또는 재개 시점의 `millis()` 값을 저장하고, `pausedTime`은 일시 정지 시까지의 경과 시간을 저장합니다. 
    * 시간은 `HH:MM:SS` 형식으로 화면 중앙에 표시됩니다. 초 단위 변경 시에만 화면을 갱신하여 효율을 높입니다. 
    * 배터리 잔량은 화면 우측 상단에 백분율로 표시되며, 10% 이하 시 깜빡임으로 경고합니다. 
    * IMU 센서를 이용한 자동 화면 회전 기능이 포함되어 있습니다. 
* **사용자 인터페이스:**
    * 화면 중앙: 경과 시간 (HH:MM:SS) 표시.
    * 화면 우측 상단: 배터리 잔량 (%) 표시.
    * 버튼 A 짧게 누름: 시계 일시 정지/재개 토글. 
    * 버튼 A 길게(1초 이상) 누름: 경과 시간 초기화. 

### 4.5. 모드 4: 수평계 모드

* **기능:** IMU 센서(가속도계)를 사용하여 장치의 기울기(Pitch, Roll) 및 회전(Yaw) 각도를 측정하고 표시합니다. 사용자는 Pitch 또는 Yaw 값 표시를 선택할 수 있으며, 현재 각도를 기준으로 센서 보정(영점 설정)이 가능합니다.
* **주요 로직:**
    * `M5.Imu.getAccelData()`를 통해 가속도 값(accX, accY, accZ)을 읽어옵니다. 
    * `atan2` 및 `asin` 함수를 사용하여 Yaw($\psi$), Pitch($\phi$), Roll($\theta$) 각도를 계산합니다. Pitch 값은 절대값으로, Yaw 값은 특정 기준에 맞춰 변환됩니다. Roll 값은 -90도에서 90도 사이로 제한됩니다. 
    * 계산된 각도 값들은 저역 통과 필터(지수 이동 평균, `alpha = 0.1`)를 거쳐 노이즈가 제거되고 부드럽게 변합니다. 
    * `offset_psi`, `offset_phi` 변수를 사용하여 현재 각도를 기준으로 영점을 보정할 수 있습니다. 
    * `usePhi` 플래그에 따라 Pitch 또는 Yaw 값을 화면에 크게 표시하고, 해당 값에 따른 그래픽 요소를 함께 표시합니다. 
        * Pitch 모드 (`usePhi == true`): Pitch 값을 숫자로 표시하고, 수직 막대(파란색)로 시각화합니다. 추가로 Roll 값을 수평 막대(노란색)로 표시합니다. 
        * Yaw 모드 (`usePhi == false`): Yaw 값을 숫자로 표시하고, 중앙을 기준으로 회전하는 선(빨간색)으로 시각화합니다. 
* **사용자 인터페이스:**
    * 화면 중앙: 선택된 각도 값(Pitch 또는 Yaw)을 큰 숫자로 표시.
    * 선택된 모드에 따라 그래픽 요소(막대 또는 회전선) 표시.
    * 버튼 A 짧게 누름: Pitch/Yaw 표시 모드 전환. 
    * 버튼 A 길게(1.5초 이상) 누름: 현재 각도를 기준으로 센서 영점 보정. 

### 4.6. 모드 5: QR 코드 모드

* **기능:** 미리 정의된 여러 개의 URL 주소에 대한 QR 코드를 순차적으로 화면에 표시합니다. 각 QR 코드에 해당하는 레이블도 함께 표시됩니다.
* **주요 로직:**
    * `qrCodes` 배열에 저장된 URL 문자열과 `qrLabels` 배열에 저장된 해당 레이블을 사용합니다. 
    * `currentQRIndex` 변수를 사용하여 현재 표시할 QR 코드의 인덱스를 관리합니다.
    * `sprite.qrcode()` 함수를 사용하여 QR 코드를 화면 중앙에 생성하고, 그 아래에 레이블을 표시합니다. 
    * IMU 센서를 이용한 자동 화면 회전 기능이 포함되어 있습니다. 
* **사용자 인터페이스:**
    * 화면 중앙: 현재 선택된 QR 코드.
    * QR 코드 하단: 해당 QR 코드의 레이블.
    * 버튼 A 짧게 누름: 다음 QR 코드로 순환 변경. 

### 4.7. 모드 6: 미정의 모드 ("?????")

* **기능:** 현재 이 모드는 "working..."이라는 텍스트만 화면에 표시합니다. 
* **주석 처리된 코드:** 주석 처리된 코드 블록을 보면, 원래 이 모드는 컴파일 시점의 날짜와 시간을 조합하여 "MPAS-FE_Ver 0.1_YYMMDDhhmmss" 형식의 펌웨어 버전 정보를 상세히 표시하려 했던 것으로 보입니다. 현재는 해당 기능이 비활성화되어 있습니다.

## 5. 주요 함수 분석

* **`setup()`**: 
    * M5StickCPlus2 시스템 초기화 (`M5.begin()`).
    * 화면 기본 설정 (회전, 배경색, 스프라이트 생성, 텍스트 속성).
    * 전원 관리, 마이크, IMU, 부저 초기화.
    * 부팅 시간 및 경과 시간 시계 시작 시간 기록.
* **`loop()`**: 
    * `M5.update()`를 호출하여 버튼 상태 등 업데이트.
    * 모드 0 또는 1에서 IMU Yaw 값에 따른 자동 화면 회전 및 모드 전환 로직 수행.
    * 배터리 잔량 확인 및 10% 이하 시 LED 깜빡임 처리.
    * `prevMode`와 `mode`를 비교하여 모드가 변경되었으면 화면을 검은색으로 지우고 텍스트 정렬을 기본값으로 복구.
    * 버튼 B 입력 처리 (짧게 누름: 모드 순환, 길게 누름: 모드별 특수 기능 또는 이전 모드 이동).
    * 현재 `mode` 값에 따라 해당 모드의 로직을 수행하는 `if` 블록 실행.
* **`calculateFrequency()`**: 
    * 마이크로부터 `SAMPLES` 개수만큼 오디오 데이터를 `micBuffer`에 기록.
    * 각 샘플에 1차 저역 통과 필터(차단 주파수 300Hz) 적용. 
    * 해밍 윈도우 적용 후 FFT 수행 (`FFT.compute()`).
    * FFT 결과로부터 복소수를 크기로 변환 (`FFT.complexToMagnitude()`).
    * `findMajorPeakInFrequencyRange()` 함수를 호출하여 0Hz부터 나이퀴스트 주파수 사이에서 가장 큰 크기를 갖는 주파수 피크를 탐색. 
    * 찾아낸 주파수 값을 이동 평균 필터(`frequencyBuffer`, `AVG_WINDOW_SIZE`)를 통해 안정화. 
    * 최종 필터링된 주파수가 30Hz 미만이거나 마이크 데이터 수신에 실패하면 0.0을 반환.
* **`applyLowPassFilter()`**: 
    * 1차 저역 통과 필터(RC 필터)를 구현합니다. 입력 값, 차단 주파수, 샘플링 주파수를 기반으로 필터링된 값을 반환합니다.
    * $RC = 1 / (2 \pi \times \text{cutoffFrequency})$
    * $dt = 1 / \text{sampleRate}$
    * $\alpha = dt / (RC + dt)$
    * $\text{outputValue} = \alpha \times \text{inputValue} + (1 - \alpha) \times \text{previousOutputValueLPF}$
* **`getBatteryPercent()`**: 
    * `M5.Power.getBatteryVoltage()`를 통해 현재 배터리 전압(mV)을 읽습니다.
    * 미리 정의된 최저 전압(`BAT_LOW = 3150mV`)과 최고 전압(`BAT_HIGH = 4100mV`) 사이 값으로 보정합니다. 
    * 보정된 전압을 기준으로 배터리 잔량을 0~100% 사이의 값으로 선형 변환합니다.
    * 표시되는 배터리 잔량의 급격한 변화를 줄이기 위해 지수 이동 평균(EMA) 필터와 유사한 스무딩 처리(`smoothedBatteryPercent = previousBatteryPercent + (currentBatteryPercent - previousBatteryPercent) * 0.1f`)를 적용 후 정수 값으로 반환합니다. 
* **`drawGraph()`**: 
    * 모드 0에서 사용되며, 화면 우측에 주파수, 속도, 배터리 전압을 나타내는 세 개의 세로 막대그래프를 그립니다.
    * 각 값(주파수, 속도, 전압)의 최대값을 기준으로 현재 값의 비율을 계산하여 막대 높이를 결정합니다. 
    * 막대는 그라데이션 색상으로 채워집니다. (`getGradientColor()` 함수 사용) 
    * 주파수 그래프 영역에는 모드 1에서 사용되는 모터들의 임계 주파수 기준선들이 함께 표시되어 현재 주파수와의 관계를 시각적으로 파악할 수 있게 합니다. 
* **`handleScreenRotation()`**: 
    * IMU의 가속도계 데이터를 사용하여 장치의 Y축 회전(psi 값)을 계산합니다.
    * 계산된 psi 값이 특정 임계값(`threshold = 45`도)을 넘어가면 화면 방향을 자동으로 전환합니다 (정방향/역방향). `isUpsideDown` 플래그를 사용하여 현재 화면 상태를 추적합니다.
    * 이 함수는 모드 2, 3, 5 에서 호출되어 자동 화면 회전을 지원합니다. 모드 0, 1, 4 에서는 각 모드 내에 유사한 화면 회전 또는 방향 감지 로직이 구현되어 있습니다.

## 6. 사용자 인터페이스 (UI/UX)

* **화면 표시:**
    * 1.14인치 LCD를 활용하여 각 모드에 필요한 정보를 텍스트 및 그래픽 형태로 명확하게 표시하려 노력했습니다.
    * 더블 버퍼링(`M5Canvas`) 사용으로 화면 깜빡임을 최소화했습니다.
    * 색상을 활용하여 정보의 종류(예: 주파수는 청록색, 속도는 주황색)나 상태(예: 배터리 부족 시 빨간색)를 구분합니다.
* **버튼 조작:**
    * **버튼 A:** 주로 각 모드 내의 주 기능 제어(시작/정지, 값 변경, 모드 전환 등)에 사용됩니다. 짧게 누름과 길게 누름(특정 시간 이상)을 구분하여 다른 기능을 할당했습니다.
        * 모드 0: 기어비/휠 크기 변경
        * 모드 1: 모터 종류 변경
        * 모드 2: 스톱워치 시작/랩/정지, 길게 누르면 카운트다운 시작
        * 모드 3: 시계 일시정지/재개, 길게 누르면 초기화
        * 모드 4: 표시 각도 변경 (Pitch/Yaw), 길게 누르면 영점 보정
        * 모드 5: QR 코드 변경
    * **버튼 B:** 주로 전체 모드 변경에 사용됩니다.
        * 짧게 누름: 다음 모드로 순환 (모드 0/1 -> 모드 2, 모드 2~5 -> 다음 모드, 모드 6 -> 모드 1). 
        * 1초~1.5초 누름: 이전 모드로 이동 (모드 1에서는 작동 안 함). 
        * 모드 2에서 2초 이상 길게 누름: 스톱워치 랩 타겟 변경. 
    * 버튼 조작 시 부저음(`realMouseClickSound1()`, `stopwatchClickSound()`, `countdownBeep()`)을 통해 사용자에게 피드백을 제공합니다.

## 7. 코드 특징 및 기타

* **필터링:** 주파수 측정 시 저역 통과 필터와 이동 평균 필터를 사용하여 노이즈를 줄이고 측정값의 안정성을 높였습니다. 배터리 잔량 표시와 그래프 값에도 스무딩 필터를 적용하여 시각적 변화를 부드럽게 했습니다.
* **모듈화 시도:** 각 모드의 로직이 `if (mode == X)` 블록으로 구분되어 있어 코드의 가독성 및 유지보수성을 높이려는 시도가 보입니다.
* **자세한 주석:** 코드 중간중간에 한글로 된 주석이 포함되어 있어 코드의 의도와 특정 로직의 이유를 이해하는 데 도움을 줍니다. (예: `//마이크로 부터 모터의 진동음을 받아 주파수를 추정하는 과정에서...`) 
* **화면 회전:** IMU 센서를 활용하여 특정 모드에서 장치의 기울기에 따라 자동으로 화면 방향을 전환하는 사용자 편의 기능이 구현되어 있습니다.
* **버전 정보:** 모드 0의 화면과 모드 6(주석 처리됨)에서 컴파일 시점의 날짜와 시간을 이용해 버전 정보를 생성하고 표시하는 부분이 있습니다. 

## 8. 결론

제공된 코드는 M5StickCPlus2의 다양한 하드웨어 기능을 효과적으로 활용하여 제작된 다목적 측정 도구입니다. 마이크를 이용한 주파수 분석, IMU를 이용한 움직임 감지 및 각도 측정 등 고급 기능을 포함하고 있으며, 사용자 편의를 위한 UI/UX 요소(버튼 조작, 시각적 피드백, 자동 화면 회전)도 고려되어 있습니다. FFT, 디지털 필터링, 센서 퓨전(간단한 형태) 등의 기술이 적용된 실용적인 임베디드 애플리케이션 예시로 볼 수 있습니다. 각 모드는 특정 목적에 맞게 잘 구성되어 있으며, 전반적으로 완성도 높은 코드입니다. 모드 6의 주석 처리된 내용은 향후 기능 확장의 가능성을 시사합니다.
